import { join } from "node:path";
// eslint-disable-next-line node/no-extraneous-import
import { jest } from "@jest/globals";
import { fileURLToPath, URL } from "node:url";
import { SourceFunctionInfo } from "../../../src/interface.js";

jest.unstable_mockModule("node:fs/promises", () => ({
  readFile: jest.fn(() => "\n".repeat(50)),
}));

// eslint-disable-next-line node/no-unsupported-features/es-syntax
const { Parser } = await import("../../../src/parser/index.js");
// eslint-disable-next-line node/no-unsupported-features/es-syntax
const { readFile } = await import("node:fs/promises");
const dirname = fileURLToPath(new URL(".", import.meta.url));

describe("Parser", () => {
  const parser = new Parser();

  test("traceParse", async () => {
    const debugFilePath = join(dirname, "..", "..", "fixture", "traceParse.debugInfo.json");
    await parser.traceParse(debugFilePath);
    expect(parser.functionCovInfoMap).toMatchSnapshot();
    expect(parser.functionCovTraceMap).toMatchSnapshot();
  });

  test("generateFunctionCoverage", () => {
    parser.generateFunctionCoverage();
    expect(parser.functionCoverageResults.length).toEqual(5);
    expect(parser.functionCoverageResults).toMatchSnapshot();
  });

  test("generateFileCoverage", async () => {
    expect(jest.isMockFunction(readFile)).toBeTruthy();
    const sourceFunction = new Map<string, SourceFunctionInfo[]>();
    sourceFunction.set("test/A.ts", [
      { name: "", range: [39, 39] },
      /** This case means that the line range of this function after instrumented is larger than
       *  the line range generated by transform
       *  It may by caused by inline function or constructor.
       */
      { name: "test/A/Foo#check", range: [20, 24] },
      { name: "", range: [4, 12] },
    ]);
    sourceFunction.set("test/B.ts", [{ name: "test/B/checkMemory", range: [45, 45] }]);
    sourceFunction.set("test/C.ts", [
      { name: "", range: [3, 40] },
      { name: "", range: [42, 44] },
    ]);
    sourceFunction.set("test/D.ts", [{ name: "test/D/visit", range: [10, 11] }]);
    await parser.generateFileCoverage(sourceFunction);
    expect(parser.fileCoverageResults).toMatchSnapshot();
  });
});
